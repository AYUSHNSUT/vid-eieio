"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlerError = exports.AccessTokenError = void 0;
/**
 * The error thrown by {@link GetAccessToken}
 *
 * @category Server
 */
class AccessTokenError extends Error {
    constructor(code, message) {
        super(message);
        // Saving class name in the property of our custom error as a shortcut.
        this.name = this.constructor.name;
        // Capturing stack trace, excluding constructor call from it.
        Error.captureStackTrace(this, this.constructor);
        // Machine readable code.
        this.code = code;
    }
}
exports.AccessTokenError = AccessTokenError;
// eslint-disable-next-line max-len
// Basic escaping for putting untrusted data directly into the HTML body, per: https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#rule-1-html-encode-before-inserting-untrusted-data-into-html-element-content
function htmlSafe(input) {
    return input
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}
/**
 * The error thrown by API route handlers.
 *
 * Because the error message can come from the OpenID Connect `error` query parameter we
 * do some basic escaping which makes sure the default error handler is safe from XSS.
 *
 * If you write your own error handler, you should **not** render the error message
 * without using a templating engine that will properly escape it for other HTML contexts first.
 *
 * @category Server
 */
class HandlerError extends Error {
    constructor(error) {
        super(htmlSafe(error.message));
        this.name = error.name;
        if ('code' in error) {
            this.code = error.code;
        }
        if ('status' in error) {
            this.status = error.status;
        }
    }
}
exports.HandlerError = HandlerError;
//# sourceMappingURL=errors.js.map